<!doctype html><html lang=es-es><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Second Lightning Talk | Equilibrist of Go Blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Temas a tratar en la segunda sesión Interface en struct y extensión de clases En el mundo clásico de la orientación a objetos, por ejemplo en Java, una interfaz define los métodos de una clase que se deben implementar para cumplir con esa interfaz. Y si una clase extiende a otra, esta hereda los métodos que tenga implementados la clase padre.
En Golang, si un struct (clase) implementa (entre otros) los métodos de una interfaz, entonces podemos usar ese struct allá donde la interfaz, pero si añadimos la interfaz dentro del struct, entonces de alguna manera extendemos ademas las implementaciones de la interfaz que hemos añadido."><meta name=generator content="Hugo 0.111.3"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/blog/ananke/css/main.min.css><meta property="og:title" content="Second Lightning Talk"><meta property="og:description" content="Temas a tratar en la segunda sesión Interface en struct y extensión de clases En el mundo clásico de la orientación a objetos, por ejemplo en Java, una interfaz define los métodos de una clase que se deben implementar para cumplir con esa interfaz. Y si una clase extiende a otra, esta hereda los métodos que tenga implementados la clase padre.
En Golang, si un struct (clase) implementa (entre otros) los métodos de una interfaz, entonces podemos usar ese struct allá donde la interfaz, pero si añadimos la interfaz dentro del struct, entonces de alguna manera extendemos ademas las implementaciones de la interfaz que hemos añadido."><meta property="og:type" content="article"><meta property="og:url" content="https://equilibristofgo.github.io/blog/posts/02-post/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-25T19:00:00+02:00"><meta property="article:modified_time" content="2023-04-25T19:00:00+02:00"><meta itemprop=name content="Second Lightning Talk"><meta itemprop=description content="Temas a tratar en la segunda sesión Interface en struct y extensión de clases En el mundo clásico de la orientación a objetos, por ejemplo en Java, una interfaz define los métodos de una clase que se deben implementar para cumplir con esa interfaz. Y si una clase extiende a otra, esta hereda los métodos que tenga implementados la clase padre.
En Golang, si un struct (clase) implementa (entre otros) los métodos de una interfaz, entonces podemos usar ese struct allá donde la interfaz, pero si añadimos la interfaz dentro del struct, entonces de alguna manera extendemos ademas las implementaciones de la interfaz que hemos añadido."><meta itemprop=datePublished content="2023-04-25T19:00:00+02:00"><meta itemprop=dateModified content="2023-04-25T19:00:00+02:00"><meta itemprop=wordCount content="931"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Second Lightning Talk"><meta name=twitter:description content="Temas a tratar en la segunda sesión Interface en struct y extensión de clases En el mundo clásico de la orientación a objetos, por ejemplo en Java, una interfaz define los métodos de una clase que se deben implementar para cumplir con esa interfaz. Y si una clase extiende a otra, esta hereda los métodos que tenga implementados la clase padre.
En Golang, si un struct (clase) implementa (entre otros) los métodos de una interfaz, entonces podemos usar ese struct allá donde la interfaz, pero si añadimos la interfaz dentro del struct, entonces de alguna manera extendemos ademas las implementaciones de la interfaz que hemos añadido."></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/blog/ class="f3 fw2 hover-white no-underline white-90 dib">Equilibrist of Go Blog</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Second Lightning Talk</h1><time class="f6 mv4 dib tracked" datetime=2023-04-25T19:00:00+02:00>April 25, 2023</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id=temas-a-tratar-en-la-segunda-sesión>Temas a tratar en la segunda sesión</h1><h2 id=interface-en-struct-y-extensión-de-clases>Interface en struct y extensión de clases</h2><p>En el mundo clásico de la orientación a objetos, por ejemplo en Java, una interfaz define los métodos de una clase que se deben implementar para cumplir con esa interfaz. Y si una clase extiende a otra, esta hereda los métodos que tenga implementados la clase padre.</p><p>En Golang, si un struct (clase) implementa (entre otros) los métodos de una interfaz, entonces podemos usar ese struct allá donde la interfaz, pero si añadimos la interfaz dentro del struct, entonces de alguna manera extendemos ademas las implementaciones de la interfaz que hemos añadido.</p><p>Links
<a href=https://eli.thegreenplace.net/2020/embedding-in-go-part-3-interfaces-in-structs/>Embedding in go (part 3) Interfaces in structs</a>
<a href=https://www.talkgolang.com/2021/05/08/extend-packages/>Extend packages</a>
<a href=https://yourbasic.org/golang/how-to-sort-in-go/>Explicacion de como funciona la libreria de ordenacion</a></p><h3 id=ejemplos-de-código>Ejemplos de código</h3><ul><li><a href=https://github.com/equilibristofgo/sandbox/tree/main/07_embedding_interface/README.md>Aquí</a></li></ul><h2 id=uso-del-contexto>Uso del contexto</h2><p>En Golang, la manera de poder compartir valores a lo largo del proceso, y que distintos hilos no mezclen valores es el uso del contexto.</p><p>En Java, por ejemplo, tenemos el ThreadLocal un objeto que la JVM nos proporciona durante el flujo de ejecución para albergar esos valores.</p><p>En el caso de Go, el objeto esta preparado para que sea &ldquo;thread-safe&rdquo; y de alguna manera se apilan los valores que se van guardando.</p><p>Algunos links de interés.
<a href=https://www.digitalocean.com/community/tutorials/how-to-use-contexts-in-go>Tutorial básico del uso del contexto</a>
<a href=https://stackoverflow.com/questions/40379960/context-withvalue-how-to-add-several-key-value-pairs>¿Como almacenar mas de una clave?</a> recordar que el objeto context solo admite una clave&mldr;</p><pre tabindex=0><code>context.WithValue(ctx, &#34;key&#34;, &#34;test-value&#34;)
</code></pre><p>por tanto si queremos almacenar mas de una&mldr; debemos aprovechar almacenar estructuras que permitan una información estructurada.
<a href=https://dev.to/gopher/getting-started-with-go-context-l7g>Mas tutoriales</a>
<a href=https://www.calhoun.io/pitfalls-of-context-values-and-how-to-avoid-or-mitigate-them/>Algunas notas generales</a></p><h3 id=ejemplos-de-código-1>Ejemplos de código</h3><ul><li><a href=https://github.com/equilibristofgo/sandbox/tree/main/06_context/README.md>Aquí</a> donde veremos<ul><li>Un ejemplo sencillo de como se almacenan y se estraen los elementos del contexto, a partir de ahi podemos usar el contexto como parametro entre metodos para hacerlo viajar asegurando su consistencia.</li><li>En el segundo ejemplo, vemos como podemos extender un contexto en otro, y acceder al contexto nativo a traves de otras implementaciones (a parte de ver como implementar un middleware proxy).</li></ul></li></ul><h2 id=visibilidades-dentro-y-fuera-de-un-paquete-para-los-atributos>Visibilidades dentro y fuera de un paquete para los atributos</h2><p>Basicamente la regla se resume en, si esta en mayuscula &mldr; es visible, pero sino, no&mldr; y eso aplica a todo, metodos, atributos&mldr;</p><pre tabindex=0><code>    t.Run(tt.name, func(t *testing.T) {
        h := serverHttp.ExampleStruct{
            Visible: &#34;&#34;,
            appServices: nil,
            logger:      tt.fields.logger,
        }
</code></pre><p>esta bien recordarlo a la hora de construir tus estructuras y metodos visibles de un paquete, porque a veces te olvidas y dices&mldr; ¿porque no veo tal atributo? &mldr; y esto aplica cuando el objeto se serializa&mldr;</p><p><a href=https://www.digitalocean.com/community/tutorials/understanding-package-visibility-in-go>Aqui</a> puedes ver un pequeño tutorial.</p><h3 id=ejemplos-de-código-2>Ejemplos de código</h3><ul><li><a href>Aquí</a></li></ul><h2 id=introducción-a-cgo-y-webassembly>Introducción a cgo y webassembly</h2><p>En este punto, vamos a hacer un repaso por distintas características del lenguaje que lo hacen diferente a otros, de como puede integrarse con otros lenguajes&mldr; incluyendo webassembly.</p><p>Empecemos con la idea de cross-compiler. Recuerdo cuando en mis inicios con Linux, me dio por instalarme Gentoo, y de como empezó la fiebre por la compilación, todo lo que se instalaba se tenia que compilar&mldr; también me dio por cacharrear con alguna placa de microcontroladores, y ahi apareció el tema de las toolchains, incluso como funcionaba el tema del multiarch en Debian. En estos casos, no era necesario compilar algo en la maquina que se iba a usar, si podías montar un entorno cross-compile ya lo tenias resuelto.</p><p>Pues en Golang, ya de fabrica, puedes compilar para distintas arquitecturas de una manera nativa, y <a href=https://dh1tw.de/2019/12/cross-compiling-golang-cgo-projects/>para el caso con el que empezamos</a> incluso compilar para Windows desde Linux. <a href=https://freshman.tech/snippets/go/cross-compile-go-programs/>Alguna referencia mas</a>.</p><p>A partir de ahi, si cogemos <a href=https://go.dev/blog/cgo>CGO</a> podríamos incluso mezclar distintos lenguajes &ldquo;parecidos&rdquo; como C y GO&mldr; en <a href=https://blog.marlin.org/cgo-referencing-c-library-in-go>este</a> caso llamar desde GO a código C.</p><p>Aqui tendriamos un listado con mas ejemplos</p><ul><li><a href=https://zchee.github.io/golang-wiki/cgo/>https://zchee.github.io/golang-wiki/cgo/</a></li><li><a href=https://riptutorial.com/go/example/21315/cgo--first-steps-tutorial>https://riptutorial.com/go/example/21315/cgo--first-steps-tutorial</a></li><li><a href=https://github.com/AlekSi/cgo-by-example/blob/master/main.go>https://github.com/AlekSi/cgo-by-example/blob/master/main.go</a></li></ul><p>Ahora bien, que tu codigo este preparado para poder compilar en distintas arquitecturas, quiza requiera que distintas partes de ese codigo usen cosas especificas para ese sistema (y que en el otro, no puedan ser compiladas). Para solucionar esta casusisticas de inclusion condicional, aparence los tags de compilacion.</p><ul><li><a href=https://kofo.dev/build-tags-in-golang>https://kofo.dev/build-tags-in-golang</a></li><li><a href=https://www.digitalocean.com/community/tutorials/customizing-go-binaries-with-build-tags-es>https://www.digitalocean.com/community/tutorials/customizing-go-binaries-with-build-tags-es</a></li><li><a href=https://www.ardanlabs.com/blog/2013/08/using-cgo-with-pkg-config-and-custom.html>https://www.ardanlabs.com/blog/2013/08/using-cgo-with-pkg-config-and-custom.html</a></li><li><a href=https://dave.cheney.net/2013/10/12/how-to-use-conditional-compilation-with-the-go-build-tool>https://dave.cheney.net/2013/10/12/how-to-use-conditional-compilation-with-the-go-build-tool</a></li></ul><p>Una casusistica donde esto suele pasar es en la gestion avanzada de red, como por ejemplo el <a href=https://www.sobyte.net/post/2021-09/golang-netpoll/>netpoll</a> pues si solo ciertas librerias funcionan en windows, entonces usaremos los tags para que compilen esa parte&mldr;</p><h3 id=bola-extra-webassembly>Bola extra. Webassembly</h3><p>Solo comentar que otro lenguaje que podemos generar <a href=https://github.com/golang/go/wiki/WebAssembly#getting-started>desde Go es Webassembly</a> Y mas adelante veremos <a href=https://egghead.io/lessons/go-configure-go-build-constraints-in-vs-code-to-work-with-webassembly>como usarlo</a></p><h3 id=ejemplos-de-código-3>Ejemplos de código</h3><ul><li>En <a href=https://github.com/equilibristofgo/sandbox/tree/main/09_cgo/README.md>este</a> ejemplo veremos como
relacionar el codigo go con c y viceversa.</li></ul><h2 id=breves>Breves</h2><h3 id=code-generator>code generator</h3><p>La generación de código (antes claro esta de la aparición de ChatGPT) siempre ha sido una opción para ciertas casuísticas, y tampoco tiene que ser mal mirado, puedes necesitar repetir ciertos soluciones en distintos lugares, por distintos motivos&mldr;</p><ul><li><a href=https://morioh.com/p/90906ca5c28e>A Yeoman Generator to Scaffold Golang-project</a> Yeoman es una solución para generar proyectos de código completo siguiendo plantillas, como Helm para generar deployments en Kubernetes.</li><li><a href=https://github.com/mirzaakhena/zapp>Is a scaffolding generator that will produce basic CRUD project complete with server and client code based on script input</a></li><li><a href=https://github.com/swagger-api/swagger-codegen>swagger-codegen</a> Bajo el mismo concepto que dada una especificación de una api se construyen un cliente/servidor&mldr; pues <a href=https://goswagger.io/generate/client.html>esta</a> es la que lo genera en GoLang.</li><li><a href=https://github.com/awalterschulze/goderive>Este enfoque quizas cambia un poco las ideas</a></li></ul><h3 id=ides-en-go>ides en go</h3><ul><li><a href=https://github.com/jmigpin/editor>editor</a></li><li><a href=https://github.com/fyne-io/fynedesk>fynedesk no es un ide, pero es interesante</a></li><li><a href=https://github.com/jmigpin/editor>Source code editor in pure Go</a></li><li><a href=https://github.com/zyedidia/micro>micro is a terminal-based text editor that aims to be easy to use and intuitive</a></li><li><a href=https://github.com/bediger4000/kilo-in-go/blob/master/kilo.go>It’s about 1000 lines of go code for an editor</a></li><li><a href=https://github.com/limetext/lime>Discontinued??? - Frontend & Backend editor concept</a></li><li><a href=https://github.com/stretto-editor/stretto>Discontinued - Stretto is a text-based editor halfway between modal editors such as Emacs or Vim, and user-friendly ones such as Atom or SublimeText.</a></li><li>Clasicos - Emacs<ul><li><a href=https://geeksocket.in/posts/emacs-lsp-go/>emacs-lsp-go</a></li><li><a href=https://dr-knz.net/a-tour-of-emacs-as-go-editor.html>emacs tour</a></li></ul></li></ul><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://equilibristofgo.github.io/blog>&copy; Equilibrist of Go Blog 2023</a><div><div class=ananke-socials></div></div></div></footer></body></html>